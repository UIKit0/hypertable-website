<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>hypertable: Hypertable::ConnectionManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_hypertable.html">Hypertable</a>::<a class="el" href="class_hypertable_1_1_connection_manager.html">ConnectionManager</a>
  </div>
</div>
<div class="contents">
<h1>Hypertable::ConnectionManager Class Reference</h1><!-- doxytag: class="Hypertable::ConnectionManager" --><!-- doxytag: inherits="Hypertable::DispatchHandler" -->Establishes and maintains a set of TCP connections.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_hypertable_1_1_dispatch_handler.html">Hypertable::DispatchHandler</a>.
<p>
<div class="dynheader">
Collaboration diagram for Hypertable::ConnectionManager:</div>
<div class="dynsection">
<p><center><img src="class_hypertable_1_1_connection_manager__coll__graph.png" border="0" usemap="#_hypertable_1_1_connection_manager__coll__map" alt="Collaboration graph"></center>
<map name="_hypertable_1_1_connection_manager__coll__map">
<area shape="rect" href="class_hypertable_1_1_dispatch_handler.html" title="Abstract base class that is the main callback class of the Comm layer." alt="" coords="17,174,212,200"><area shape="rect" href="class_hypertable_1_1_reference_count.html" title="This class is meant to be a base class for all classes that want to be referenced..." alt="" coords="19,96,211,123"><area shape="rect" href="structatomic__t.html" title="atomic_t" alt="" coords="133,6,205,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_hypertable_1_1_connection_manager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_hypertable_1_1_connection_manager_1_1_lt_connection_state.html">LtConnectionState</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager_1_1_shared_impl.html">SharedImpl</a></td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef intrusive_ptr<br class="typebreak">
&lt; <a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#ae4a771f169bc7718aa5f6082faed993">ConnectionStatePtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::intrusive_ptr<br class="typebreak">
&lt; <a class="el" href="class_hypertable_1_1_connection_manager_1_1_shared_impl.html">SharedImpl</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#dcba5f6ef4a287aadfbcb556894d8143">SharedImplPtr</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#35cea429c36a77c77c4b1c4dcaf424da">ConnectionManager</a> (<a class="el" href="class_hypertable_1_1_comm.html">Comm</a> *comm=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#35cea429c36a77c77c4b1c4dcaf424da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#d31170e904a6220e401c1143bb3abcee">ConnectionManager</a> (const <a class="el" href="class_hypertable_1_1_connection_manager.html">ConnectionManager</a> &amp;cm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#d31170e904a6220e401c1143bb3abcee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#c084866426806920b97828e432e10285">~ConnectionManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#c084866426806920b97828e432e10285"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#6f53f3e6cc889c38d06c48cf93a2c1fb">add</a> (const sockaddr_in &amp;addr, uint32_t timeout_ms, const char *service_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a connection to the connection manager.  <a href="#6f53f3e6cc889c38d06c48cf93a2c1fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#73119928f17214dd2a2b3e9da93161aa">add</a> (const sockaddr_in &amp;addr, uint32_t timeout_ms, const char *service_name, <a class="el" href="namespace_hypertable.html#be9c0c322c8046d0d9354fa21badf501">DispatchHandlerPtr</a> &amp;handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as above method except installs a dispatch handler on the connection.  <a href="#73119928f17214dd2a2b3e9da93161aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#6517467f7b68b3d29d453290d8aee1c7">add</a> (const sockaddr_in &amp;addr, const sockaddr_in &amp;local_addr, uint32_t timeout_ms, const char *service_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a connection to the connection manager with a specific local address.  <a href="#6517467f7b68b3d29d453290d8aee1c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#acea4e510728f5cfdb93b24eaedc6fca">add</a> (const sockaddr_in &amp;addr, const sockaddr_in &amp;local_addr, uint32_t timeout_ms, const char *service_name, <a class="el" href="namespace_hypertable.html#be9c0c322c8046d0d9354fa21badf501">DispatchHandlerPtr</a> &amp;handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as above method except installs a dispatch handler on the connection.  <a href="#acea4e510728f5cfdb93b24eaedc6fca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#17c4820a28c9f9571e827ec5d5b2f74b">remove</a> (struct sockaddr_in &amp;addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a connection from the connection manager.  <a href="#17c4820a28c9f9571e827ec5d5b2f74b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#3d36e9e3a53d27f9fb9ddb04e49e18cf">wait_for_connection</a> (const sockaddr_in &amp;addr, uint32_t max_wait_ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method blocks until the connection to the given address is established.  <a href="#3d36e9e3a53d27f9fb9ddb04e49e18cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#d98d6210e6ffceb1360de1eceecdd0cb">wait_for_connection</a> (const sockaddr_in &amp;addr, <a class="el" href="class_hypertable_1_1_timer.html">Timer</a> &amp;timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method blocks until the connection to the given address is established.  <a href="#d98d6210e6ffceb1360de1eceecdd0cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hypertable_1_1_comm.html">Comm</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#8bdcf7ea409fbdee6180f53b72eddb4a">get_comm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="class_hypertable_1_1_comm.html" title="Provides communication (message passing) services to an application.">Comm</a> object associated with this connection manager.  <a href="#8bdcf7ea409fbdee6180f53b72eddb4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#3e4f5c32cf6c45083e042fc2dc75f9bc">set_quiet_mode</a> (bool mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets a 'quiet_mode' flag which can disable the generation of log messages upon failed connection attempts.  <a href="#3e4f5c32cf6c45083e042fc2dc75f9bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#64d32639f3dec20bd4301d5c7b738064">handle</a> (<a class="el" href="namespace_hypertable.html#a8cafde9646a93ee97cfb6b26a9ec9b2">EventPtr</a> &amp;event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the comm layer dispatch callback method.  <a href="#64d32639f3dec20bd4301d5c7b738064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#4b6fe917e7be3812c4fdafa84b103a89">operator()</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the Boost thread "run" method.  <a href="#4b6fe917e7be3812c4fdafa84b103a89"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#cee8344dd731e118249fc494085ad5f8">send_connect_request</a> (<a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a> *conn_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to establish a connection for the given <a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a> object.  <a href="#cee8344dd731e118249fc494085ad5f8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hypertable_1_1_connection_manager.html#dcba5f6ef4a287aadfbcb556894d8143">SharedImplPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hypertable_1_1_connection_manager.html#17526ad5935aae9516a7a0e3295cc14a">m_impl</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Establishes and maintains a set of TCP connections. 
<p>
If any of the connections gets broken, then this class will continuously attempt to re-establish the connection, pausing for a while in between attempts. 
<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00055">55</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="ae4a771f169bc7718aa5f6082faed993"></a><!-- doxytag: member="Hypertable::ConnectionManager::ConnectionStatePtr" ref="ae4a771f169bc7718aa5f6082faed993" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef intrusive_ptr&lt;<a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a>&gt; <a class="el" href="class_hypertable_1_1_connection_manager.html#ae4a771f169bc7718aa5f6082faed993">Hypertable::ConnectionManager::ConnectionStatePtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00071">71</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dcba5f6ef4a287aadfbcb556894d8143"></a><!-- doxytag: member="Hypertable::ConnectionManager::SharedImplPtr" ref="dcba5f6ef4a287aadfbcb556894d8143" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::intrusive_ptr&lt;<a class="el" href="class_hypertable_1_1_connection_manager_1_1_shared_impl.html">SharedImpl</a>&gt; <a class="el" href="class_hypertable_1_1_connection_manager.html#dcba5f6ef4a287aadfbcb556894d8143">Hypertable::ConnectionManager::SharedImplPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00107">107</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="35cea429c36a77c77c4b1c4dcaf424da"></a><!-- doxytag: member="Hypertable::ConnectionManager::ConnectionManager" ref="35cea429c36a77c77c4b1c4dcaf424da" args="(Comm *comm=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Hypertable::ConnectionManager::ConnectionManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hypertable_1_1_comm.html">Comm</a> *&nbsp;</td>
          <td class="paramname"> <em>comm</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
Creates a thread to do connection retry attempts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comm</em>&nbsp;</td><td>Pointer to the comm object </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00115">115</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d31170e904a6220e401c1143bb3abcee"></a><!-- doxytag: member="Hypertable::ConnectionManager::ConnectionManager" ref="d31170e904a6220e401c1143bb3abcee" args="(const ConnectionManager &amp;cm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Hypertable::ConnectionManager::ConnectionManager           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_hypertable_1_1_connection_manager.html">ConnectionManager</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor. 
<p>
Shares the implementation with object being copied. 
<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00127">127</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c084866426806920b97828e432e10285"></a><!-- doxytag: member="Hypertable::ConnectionManager::~ConnectionManager" ref="c084866426806920b97828e432e10285" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Hypertable::ConnectionManager::~ConnectionManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00135">135</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="acea4e510728f5cfdb93b24eaedc6fca"></a><!-- doxytag: member="Hypertable::ConnectionManager::add" ref="acea4e510728f5cfdb93b24eaedc6fca" args="(const sockaddr_in &amp;addr, const sockaddr_in &amp;local_addr, uint32_t timeout_ms, const char *service_name, DispatchHandlerPtr &amp;handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::add           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_hypertable.html#be9c0c322c8046d0d9354fa21badf501">DispatchHandlerPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as above method except installs a dispatch handler on the connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The IP address to maintain a connection to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local_addr</em>&nbsp;</td><td>The local address to bind to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>The timeout value (in milliseconds) that gets passed into <a class="el" href="class_hypertable_1_1_comm.html#ab29af416a46e5ef940203207fa9ffab" title="Establishes a TCP connection to the address given by the addr argument and associates...">Comm::connect</a> and also used as the waiting period betweeen connection attempts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>service_name</em>&nbsp;</td><td>The name of the serivce at the other end of the connection used for descriptive log messages </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>This is the default handler to install on the connection. All events get changed through to this handler. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00084">84</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="6517467f7b68b3d29d453290d8aee1c7"></a><!-- doxytag: member="Hypertable::ConnectionManager::add" ref="6517467f7b68b3d29d453290d8aee1c7" args="(const sockaddr_in &amp;addr, const sockaddr_in &amp;local_addr, uint32_t timeout_ms, const char *service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::add           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>local_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a connection to the connection manager with a specific local address. 
<p>
The address structure addr holds an address that the connection manager should maintain a connection to. This method first checks to see if the address is already registered with the connection manager and returns immediately if it is. Otherwise, it adds the address to an internal connection map, attempts to establish a connection to the address, and then returns. From here on out, the internal manager thread will maintian the connection by continually re-establishing the connection if it ever gets broken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The IP address to maintain a connection to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local_addr</em>&nbsp;</td><td>The local address to bind to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>When connection dies, wait this many milliseconds before attempting to reestablish </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>service_name</em>&nbsp;</td><td>The name of the serivce at the other end of the connection used for descriptive log messages </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00113">113</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="73119928f17214dd2a2b3e9da93161aa"></a><!-- doxytag: member="Hypertable::ConnectionManager::add" ref="73119928f17214dd2a2b3e9da93161aa" args="(const sockaddr_in &amp;addr, uint32_t timeout_ms, const char *service_name, DispatchHandlerPtr &amp;handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::add           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_hypertable.html#be9c0c322c8046d0d9354fa21badf501">DispatchHandlerPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as above method except installs a dispatch handler on the connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The IP address to maintain a connection to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>The timeout value (in milliseconds) that gets passed into <a class="el" href="class_hypertable_1_1_comm.html#ab29af416a46e5ef940203207fa9ffab" title="Establishes a TCP connection to the address given by the addr argument and associates...">Comm::connect</a> and also used as the waiting period betweeen connection attempts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>service_name</em>&nbsp;</td><td>The name of the serivce at the other end of the connection used for descriptive log messages </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>This is the default handler to install on the connection. All events get changed through to this handler. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00048">48</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="6f53f3e6cc889c38d06c48cf93a2c1fb"></a><!-- doxytag: member="Hypertable::ConnectionManager::add" ref="6f53f3e6cc889c38d06c48cf93a2c1fb" args="(const sockaddr_in &amp;addr, uint32_t timeout_ms, const char *service_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::add           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>service_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a connection to the connection manager. 
<p>
The address structure addr holds an address that the connection manager should maintain a connection to. This method first checks to see if the address is already registered with the connection manager and returns immediately if it is. Otherwise, it adds the address to an internal connection map, attempts to establish a connection to the address, and then returns. From here on out, the internal manager thread will maintian the connection by continually re-establishing the connection if it ever gets broken.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>The IP address to maintain a connection to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>When connection dies, wait this many milliseconds before attempting to reestablish </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>service_name</em>&nbsp;</td><td>The name of the serivce at the other end of the connection used for descriptive log messages </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00076">76</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="8bdcf7ea409fbdee6180f53b72eddb4a"></a><!-- doxytag: member="Hypertable::ConnectionManager::get_comm" ref="8bdcf7ea409fbdee6180f53b72eddb4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hypertable_1_1_comm.html">Comm</a>* Hypertable::ConnectionManager::get_comm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <a class="el" href="class_hypertable_1_1_comm.html" title="Provides communication (message passing) services to an application.">Comm</a> object associated with this connection manager. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the assocated comm object </dd></dl>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00248">248</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="64d32639f3dec20bd4301d5c7b738064"></a><!-- doxytag: member="Hypertable::ConnectionManager::handle" ref="64d32639f3dec20bd4301d5c7b738064" args="(EventPtr &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::handle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_hypertable.html#a8cafde9646a93ee97cfb6b26a9ec9b2">EventPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event_ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the comm layer dispatch callback method. 
<p>
This is the AsyncComm dispatch handler method.<p>
It should only get called by the AsyncComm subsystem.<p>
It gets called for each connection related event (establishment, disconnect, etc.) for each connection. For connect events, the connection's connected flag is set to true and it's condition variable is signaled. For all other events (e.g. disconnect or error), the connection's connected flag is set to false and a retry is scheduled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event_ptr</em>&nbsp;</td><td>shared pointer to event object </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="class_hypertable_1_1_dispatch_handler.html#e1f871312036aeb52e8e391ad0d70b55">Hypertable::DispatchHandler</a>.</p>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00254">254</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="4b6fe917e7be3812c4fdafa84b103a89"></a><!-- doxytag: member="Hypertable::ConnectionManager::operator()" ref="4b6fe917e7be3812c4fdafa84b103a89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::operator()           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the Boost thread "run" method. 
<p>
This is the boost::thread run method.<p>
It is called by the manager thread when it starts up. 
<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00301">301</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="17c4820a28c9f9571e827ec5d5b2f74b"></a><!-- doxytag: member="Hypertable::ConnectionManager::remove" ref="17c4820a28c9f9571e827ec5d5b2f74b" args="(struct sockaddr_in &amp;addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConnectionManager::remove           </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a connection from the connection manager. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>remote address of connection to remove </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="namespace_hypertable_1_1_error.html">Error</a> code (<a class="el" href="namespace_hypertable_1_1_error.html#73c48f53deb2941a8c0ef156a899c3b20a5285a55ffe0563faf08208db78e4a6">Error::OK</a> on success) </dd></dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00216">216</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="cee8344dd731e118249fc494085ad5f8"></a><!-- doxytag: member="Hypertable::ConnectionManager::send_connect_request" ref="cee8344dd731e118249fc494085ad5f8" args="(ConnectionState *conn_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionManager::send_connect_request           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a> *&nbsp;</td>
          <td class="paramname"> <em>conn_state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to establish a connection for the given <a class="el" href="class_hypertable_1_1_connection_manager_1_1_connection_state.html">ConnectionState</a> object. 
<p>
If a failure occurs, it prints an error message and then schedules a retry by updating the next_retry member of the conn_state object and pushing it onto the retry heap<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conn_state</em>&nbsp;</td><td>The connection state record </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00171">171</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="3e4f5c32cf6c45083e042fc2dc75f9bc"></a><!-- doxytag: member="Hypertable::ConnectionManager::set_quiet_mode" ref="3e4f5c32cf6c45083e042fc2dc75f9bc" args="(bool mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hypertable::ConnectionManager::set_quiet_mode           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets a 'quiet_mode' flag which can disable the generation of log messages upon failed connection attempts. 
<p>
It is set to false by default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The new value for the quiet_mode flag </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00257">257</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d98d6210e6ffceb1360de1eceecdd0cb"></a><!-- doxytag: member="Hypertable::ConnectionManager::wait_for_connection" ref="d98d6210e6ffceb1360de1eceecdd0cb" args="(const sockaddr_in &amp;addr, Timer &amp;timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConnectionManager::wait_for_connection           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hypertable_1_1_timer.html">Timer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method blocks until the connection to the given address is established. 
<p>
The given address must have been previously added with a call to Add. If the connection is not established before the timer expires, then the method returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>the address of the connection to wait for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>running timer object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if connected, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00129">129</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d36e9e3a53d27f9fb9ddb04e49e18cf"></a><!-- doxytag: member="Hypertable::ConnectionManager::wait_for_connection" ref="3d36e9e3a53d27f9fb9ddb04e49e18cf" args="(const sockaddr_in &amp;addr, uint32_t max_wait_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ConnectionManager::wait_for_connection           </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>max_wait_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method blocks until the connection to the given address is established. 
<p>
The given address must have been previously added with a call to Add. If the connection is not established within max_wait_ms, then the method returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>the address of the connection to wait for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_wait_ms</em>&nbsp;</td><td>The maximum time to wait for the connection before returning </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if connected, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="_connection_manager_8cc_source.html#l00121">121</a> of file <a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="17526ad5935aae9516a7a0e3295cc14a"></a><!-- doxytag: member="Hypertable::ConnectionManager::m_impl" ref="17526ad5935aae9516a7a0e3295cc14a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hypertable_1_1_connection_manager.html#dcba5f6ef4a287aadfbcb556894d8143">SharedImplPtr</a> <a class="el" href="class_hypertable_1_1_connection_manager.html#17526ad5935aae9516a7a0e3295cc14a">Hypertable::ConnectionManager::m_impl</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="_connection_manager_8h_source.html#l00275">275</a> of file <a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/Users/doug/src/hypertable/src/cc/AsyncComm/<a class="el" href="_connection_manager_8h_source.html">ConnectionManager.h</a><li>/Users/doug/src/hypertable/src/cc/AsyncComm/<a class="el" href="_connection_manager_8cc_source.html">ConnectionManager.cc</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Aug 15 09:01:21 2009 for hypertable by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
